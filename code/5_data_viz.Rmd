### Title: 2023_10_23_LSG_polyseq Analysis
### Author: Kate Johnson
### Date: 11/01/23
### Add'tl Notes:

# setup
libraries
```{r}
# all-purpose data analysis tools
library(tidyverse)
# ggplot extension
library(cowplot)
# repeling labels in ggplot
library(ggrepel)
#correlation plots
library(corrplot)
# easier string formatting
library(glue)
# filepath manipulation
library(fs)

# edgeR and limma for DE analysis
library(edgeR)
library(limma)

# for reading/writing .gct files
#library(cmapR)

# for working with matrices (especially sparse ones)
library(Matrix)

#complex heatmap /plotting
library(ComplexHeatmap)
library(circlize) #for colorRamp2 color scaling
library(monochromeR) # for generating palettes
library(ggpubr) #arranging plots, stat_cor()
library(emojifont) #for help rendering unicode text
```
theme
```{r}
# Plot settings ----
#compress PDFs
tools::compactPDF('mypdfs/',  gs_quality='screen')
###PLOTTING THEME ###
theme_update(text = element_text(size = rel(4)),
             legend.title = element_text(size = rel(2.5)),
             legend.key.size = unit(.5, 'inches'),
             legend.text = element_text(size = rel(2)),
             panel.background = element_rect(fill = "white", colour = "black"),
             axis.line = element_blank(),
             axis.text.x = element_text(size=rel(3)),
             axis.text.y = element_text(size=rel(3)),
             axis.title.y = element_text(margin=margin(t = 0, r = 0.3, b = 0, l = 0.5), size=rel(3)),
             axis.title.x = element_text(size=rel(3)),
             plot.title = element_text(size = rel(3), face= "bold", hjust=0.5),
             plot.margin = unit(c(0.2, 0.2, 0.2, 0.2), "inches"),
             strip.text.x = element_text(size = rel(4), face = "bold", margin = margin(0.05,0.05,0.05,0.05, "cm")),
             strip.text.y = element_text(size = rel(4), face = "bold", margin = margin(0.05,0.05,0.05,0.05, "cm")),
             strip.background = element_rect(linewidth=0.35, color="black")) #trbl
```


directories
```{r}
wd = getwd()
# For accessing shared data on server
shared_dir = "/Volumes/nchevrier/katej/projects/polysome-seq/2023_10_23_LSG_polyseq/bcbio"
# For reading in counts/metadata
input_dir = path(wd, "../input/data/2_formatted_data")
# For saving plots  
output_dir = path(wd, "../output/2023_10_30-LSG")
# For reading in protein data from interaction scoring project folder
prot_input_dir = path(wd, "../../Interaction_Scoring/output/09_21_2022/Compiled_data")
```

sources
```{r}

```

#complex heatmap plot fxn
move to plotting functions!
```{r}
do_plot = function(file_name, w, h, p) {
  pdf(file=path(output_dir, file_name), width = w, height = h)
      draw(p)
      dev.off()
}
```

# Read in Data
```{r, warnings =F}

#counts
counts = read_csv(path(input_dir, "20231101_LSG_polysome_counts.csv")) 
#rename gene column
colnames(counts)[1] = "gene"
# format matrix to be ready for de analysis
genes <- counts$gene
counts$gene <- NULL
rownames(counts) <- genes

#meta        
metadata = read_csv(path(input_dir, "20231101_LSG_polysome_metadata.csv")) %>%
           #drop unused first col
           select(-1)
```
# QC

complexity
- ratio of unique molecules to the number of reads
- unique molecular identifiers (UMIs) allow us to collapse molecules that we read multiple times
    - A higher complexity means more information for the amount of reads we have
- calculate complexity by comparing the UMI counts (`counts`) to the uncollapsed read counts 
- should be ~0.6, so a large deviation below that might be cause for concern
- raw read counts are called "tagcounts-dupes" by bcbio

```{r}
## make a table of total counts per sample
counts_summary = enframe(colSums(counts), name='Name', value='counts') %>%
    left_join(metadata)

# read in raw read counts
counts_dir = path(shared_dir, "final/2023-10-31_bcbio")

# read matrix
reads = readMM(path(counts_dir, 'tagcounts-dupes.mtx'))

# add rownames and colnames
rownames(reads) = read_lines(path(counts_dir, 'tagcounts-dupes.mtx.rownames'))
colnames(reads) = read_lines(path(counts_dir, 'tagcounts-dupes.mtx.colnames'))

## calculate counts for reads and add to summary table
# get read counts
reads = enframe(colSums(reads), name = 'sample', value = 'read_counts') %>%
        rename_all(~str_to_title(.))

# join to counts
counts_summary = left_join(counts_summary, reads)

#plot
p<-counts_summary %>%
    mutate(complexity = counts / Read_counts) %>%
    ggplot(aes(str_c(pool, "_", replicate),
               complexity, fill=pool)) + 
        geom_col() + 
        facet_grid(. ~ treatment) + 
        labs(x = "Polysome Fraction", title = "Sample Complexity (UMIs / Uncollapsed Read Counts)") +
        #guides(fill = 'none') + 
        theme(axis.text.x = element_text(angle = 45, hjust = .5, vjust = .5, size = rel(0.5)),
              plot.title = element_text(hjust = 0.5))

#save_plot
save_plot(path(output_dir, "QC_plots/sample_complexity_replicate_barplot.pdf"),p)

```

counts per sample
```{r}
p<-ggplot(counts_summary, aes(str_c(pool, '_', replicate), 
                   counts, fill=pool)) + 
    geom_col() + 
    facet_grid(treatment ~ .) + 
    #scale_y_log10() +
    #guides(fill = 'none') + 
    xlab('Polysome Fraction') +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = .5))

save_plot(path(output_dir, "QC_plots/counts_per_sample.pdf"), p, dpi = 90)
```

replicate correlation
```{r}
# commenting out for now bc not particularly informative
#pairwise correlations between samples for each treatment
#for(treatment in unique(metadata$treatment)){
#    suppressWarnings(
#        gplots::heatmap.2(cor(counts[, metadata$treatment == treatment]),
#                          trace = 'none', Rowv=F, Colv=F, 
#                         col=viridis::viridis(75),
#                          margins = c(10, 10))
#    )
#}

# table of all pairwise correlations < 0.9
# get all pairwise correlations
cormelt = as_tibble(reshape2::melt(cor(counts)))
colnames(cormelt) = c('s1', 's2', 'cor')

filt_cormelt = cormelt %>%
    # extract pieces of name for sample 1
    extract(s1, c('treatment', 'replicate1', 'pool'), '(.*)_(.*)_(.*)') %>%
    # extract pieces of name for sample 2
    extract(s2, c('treatment2', 'replicate2', 'pool2'), '(.*)_(.*)_(.*)') %>%
    # only keep samples where treatment and pool match
    # replicate1 < replicate2 removes duplicate comparisons
    filter(treatment == treatment2, pool == pool2, replicate1 < replicate2) %>%
    # comparison column makes for easier reading
    mutate(comparison = str_c(replicate1, '-', replicate2)) %>%
    # remove extraneous columns
    select(-treatment2, -pool2, -replicate1, -replicate2) #%>%
    # all correlations are above 0.9 so keep everything for now
    # filter(cor < .9)


p<-ggplot(filt_cormelt,
       aes(x = treatment, y = pool, fill = cor)) +
       geom_tile() +
       geom_text(aes(label = round(cor,3)), 
                  hjust = 0.5, vjust = 0.5) +
       facet_wrap(~comparison)
  
#save plot 
save_plot(path(output_dir, "QC_plots/replicate_correlation.pdf"),p, dpi = 90)
```


# Data Normalization
```{r}
#set cpm thresholds (keep low to start)
cpm_threshold = 10
cpm_needed = 2

groups <- factor(str_c(metadata$treatment, '_', metadata$pool))
dge = DGEList(counts = counts, group = groups)
dge_norm = calcNormFactors(dge)
isexpr = rowSums(cpm(dge_norm) > cpm_threshold) >= cpm_needed

dge_norm_fltd = dge_norm[isexpr, ]

cpm = cpm(dge_norm_fltd) #dropped to ~8,000 genes
cpm_all = cpm(dge_norm)

# reorder cols so its easier to open in morpheus
# use metadata to help establish order
metadata = metadata %>%
           arrange(treatment, pool, replicate)
cpm = cpm[,metadata$Name]

#save cpm heatmaps for plotting in morpheus
#write.csv(as.matrix(cpm), path(output_dir, "cpm_tables/20231101_LSG_cpmTable_filt.csv"))
#write.csv(as.matrix(cpm_all), path(output_dir, "cpm_tables/20231101_LSG_cpmTable_all.csv"))

```

PCA
```{r}
# run pca
pca = prcomp(t(cpm), center=T, scale=T)
# combine pca results with metadata for easy plotting
pca_res = bind_cols(metadata, as_tibble(pca$x))

# plot

# color by treatment
p1<-ggplot(pca_res, aes(PC1, PC2, color=treatment)) + 
    geom_point(size=2) +
    scale_color_manual(values = c("grey", "peachpuff1","#F68064"))

# color by pool
p2<-ggplot(pca_res, aes(PC1, PC2, color=pool)) + 
    geom_point(size=2) +
    scale_color_manual(values = c("#68C3A5", "#B9CEE6", "#8C9FCA","#707FA1"))

# color by replicate
p3<-ggplot(pca_res, aes(PC1, PC2, color=replicate)) + 
    geom_point(size=2)

# save plots
save_plot(path(output_dir, "QC_plots/PCA/PCA_by_treatment.pdf"),p1,dpi=90)
save_plot(path(output_dir, "QC_plots/PCA/PCA_by_pool.pdf"),p2,dpi=90)
save_plot(path(output_dir, "QC_plots/PCA/PCA_by_replicate.pdf"),p3,dpi=90)
```


# DE analysis
The general steps for modeling are: 
1. Filter cpm and metadata based on the analysis at hand
2. Make a design matrix specifying the experimental condition of each sample 
3. Run `voom()` to transform and prepare data
4. Run initial `lmFit()` to fit data
5. Setup contrasts between groups for tests you want to run
    1. List contrasts
    2. Make contrast matrix
6. Run `contrast.fit()` to fit contrasts
7. Run `eBayes` to estimate statistic results
8. Gather results into useful tables

```{r}
# FILTER COUNTS & METADATA TO DROP BAD REPLICATE----
# LSGh6 input rep1 has low counts and clusters poorly -- so we will drop it
# set cpm thresholds (keep low to start)
cpm_threshold = 10
cpm_needed = 2

## first filter out samples we want to exclude from analysis (in both counts & meta)
counts_filt = counts %>%
              select(-LSG6h_Rep1_Input)
meta_filt = metadata %>% filter(Name %in% colnames(counts_filt))

# re-order counts to match order of meta data
counts_filt = counts_filt[, meta_filt$Name]
rownames(counts_filt) = rownames(counts) #add back in lost gene names

# check that col order of counts_filt and row order of meta_filt match
sum(colnames(counts_filt) == meta_filt$Name) #sum is 35 (same as so looks like all match)

## add in polysome and weighted polysome columns to counts table (do this before normalization!)
# to start pivot the counts table longer to separate out necessary conditions
# then pivot back wider so relevant pools are each their own column (and replicates are repeated down each row)
# finally do some addition!!
counts_filt_poly = counts_filt %>%
                   rownames_to_column(var = "gene") %>%
                   pivot_longer(cols = -gene, names_to = "Name", values_to = "Value") %>%
                   # separate various components of name so that we can pivot based on pools                 
                   separate(Name, into = c("Treatment", "Rep", "Pool"), sep = "_") %>%
                   pivot_wider(names_from = "Pool", values_from = "Value") %>% 
                   # this pivot wider will introduce NA's so will have to re-drop later
                   # create new columns with relevant calculations!
                   mutate(Polysome = Pool2 + Pool3,
                          Weighted.Polysome = Pool1 + 2*Pool2 + 4*Pool3) %>%
                   # now pivot longer/wider again to make into full counts table
                   pivot_longer(cols = Input:Weighted.Polysome, names_to = "Pool", values_to = "Value") %>%
                   pivot_wider(names_from = c(Treatment, Rep, Pool), values_from = Value) %>%
                   #drop LSG6h rep 1 input column again 
                   select(-LSG6h_Rep1_Input) %>%
                   #put rownames back on
                   column_to_rownames(var = "gene")
          
## re-make meta table accordingly (or just rbind necessary rows...?)
# extract name info for new cols & make data frame
additional_cols = data.frame(
                  # add empty cols to match existing meta df
                  Sample = "",
                  Barcode = "", 
                  Sample_Number = "",
                  # add in new samples
                  Name = colnames(counts_filt_poly)[!(colnames(counts_filt_poly) %in% 
                                                                   meta_filt$Name)]
                  ) %>%
                  separate(Name, into = c("treatment", "replicate", "pool"), sep = "_", remove = F) %>%
                  mutate(polysome_frac = pool) %>%
                  rename(`Sample Number` = Sample_Number)

meta_filt_poly = meta_filt %>% 
                 rbind(additional_cols) %>%
                 mutate(pool = factor(pool, 
                                      levels = c("Input", "Pool1", "Pool2", "Pool3", "Polysome", "Weighted.Polysome"))) %>%
                 arrange(treatment, pool, replicate)

# re-order counts table by meta order one more time
counts_filt_poly = counts_filt_poly[,meta_filt_poly$Name]

#check that order is same
sum(colnames(counts_filt_poly) == meta_filt_poly$Name)

## re-do dge list object creation using adjusted counts table
groups <- factor(str_c(meta_filt_poly$treatment, '_', meta_filt_poly$pool))
dge = DGEList(counts = counts_filt_poly, group = groups)
dge_norm = calcNormFactors(dge)
isexpr = rowSums(cpm(dge_norm) > cpm_threshold) >= cpm_needed
dge_norm_fltd = dge_norm[isexpr, ]


# DESIGN MATRIX----
# create factor with all conditions in experiment
f <- factor(groups, levels=unique(groups))

# build a design matrix for modeling with limma voom and indicating condition for each sample
design <- model.matrix(~0 + f)

# renames column names in the design (remove extra "f" at beginning of each group name)
colnames(design) <- sub("f", "", colnames(design))
rownames(design) <- colnames(counts_filt_poly)

##LIMMA VOOM 

# limma voom transforms count data to log2-counts per million (log2-cpm) with associated weights
# estimate the mean-variance relationship and use this to compute appropriate observational-level weights.
# The data are then ready for linear modeling.
y <- voom(dge_norm_fltd, design, plot=T)

# fit linear model for each gene given a series of arrays
fit <- lmFit(y, design)

##CONTRAST MATRIX----
# each contrast for DE will be one pool in treated - control (ie. LSG2h_input - Control_input)
# 1. get all treatments that arent control
# 2. make an equivalent list with the same pools in control
# 3. subtract 1 - 2
all_cond = levels(groups)[!grepl("Control", (levels(groups)))]
conts = gsub(".*_", "Control_", all_cond)
contrasts_list = str_c(all_cond, " - ", conts)

contrast.matrix <- makeContrasts(contrasts = contrasts_list, levels = design)

#do some renaming of scores to facilitate pivoting later on and make our lives easier...
contrast.matrix = contrast.matrix %>%
                  as.data.frame %>% #convert to df for now for manipulation
                  rename_with(., ~gsub(" - Control.*", "", .)) %>%
                  as.matrix()

fit.cont <- contrasts.fit(fit, contrast.matrix)

e.fit <- eBayes(fit.cont)

#first bind together all LFC lists for all genes from ea. contrast
log2FC.all = as.data.frame(map_dfc(1:length(colnames(e.fit$contrasts)),
                             function(coef) topTable(e.fit, coef=coef, number=Inf, adjust = "BH",
                                                     sort.by='none')$logFC)) %>%
      data.frame()

adj_p = as.data.frame(map_dfc(1:length(colnames(e.fit$contrasts)),
                                    function(coef) topTable(e.fit, coef=coef, adjust = "BH",
                                                            number=Inf,
                                                            sort.by='none')$adj.P.Val))

rownames(log2FC.all) = rownames(adj_p) = make.unique(rownames(dge_norm_fltd), sep = ".")
colnames(log2FC.all) = colnames(adj_p) = colnames(e.fit$contrasts)

#turn log2FC.all.binary into matrix of -1,0,1
FDR_thresh = 0.01
log2FC.all.binary = adj_p %>%
              mutate_all(~ifelse(. < FDR_thresh, 1, 0))

#filter LFC matrix accordingly
log2FC.all.binary[(log2FC.all < 0) == T] = -1 * log2FC.all.binary[(log2FC.all < 0) == T]
names = rownames(log2FC.all.binary)
log2FC.all.binary = log2FC.all.binary %>%
               data.frame()

DE_log2FC.all = log2FC.all[rowSums(log2FC.all.binary != 0) > 0,] %>%
          data.frame()
rownames(DE_log2FC.all) = rownames(log2FC.all)[rowSums(log2FC.all.binary != 0) > 0]

#filter DE matrix based on LFC thresh
LFC_thresh = 1
DE_LFC_thresh = DE_log2FC.all %>%
          filter_all(any_vars(abs(.) > LFC_thresh))

#write csvs of DEGs and all log2FC
write.csv(as.matrix(DE_LFC_thresh), path(output_dir, "DE_analysis/filtered/FDR0.1_LFC1/20231101_filtered_FDR0.1_LFC1_DE-genes-lfcTable.csv"))

```

# Translation Efficiency ----
First plot % of total transcripts in each pool (take cpm in each pool and divide by input cpm)
Use only DE genes 
We will use this to help assess different methods of calculating TE
- First use FDR < 0.01 |LFC| > 0 (~7304 genes)
```{r}

#bind rownames as its own column ('gene') to make sure gene names dont get lost during manipulation
percent_transcript = cbind(gene = rownames(DE_log2FC.all), cpm[rownames(DE_log2FC.all),]) %>%
                     #make df for easier manipulation
                     data.frame() %>%
                     #pivot longer so we can average over replicates
                     pivot_longer(cols = -gene, names_to ="Name", values_to = "cpm") %>%
                     #split "Name" column into relevant info
                     separate(Name, into = c("Treatment", "Rep", "Pool"), sep="_") %>%
                     #pivot wider to get reps in separate cols
                     pivot_wider(names_from = "Rep", values_from = "cpm") %>%
                     #make cpm numeric (preserving NA values)
                     mutate_at(.vars = vars(Rep1:Rep3), ~ifelse(!(is.na(.)), as.numeric(.), .)) %>%
                     #calculate average
                        #struggling to get rowwise operations working correctly
                        #so sticking to a more manual calc for now
                     mutate(Avg_cpm = (Rep1 + Rep2 + Rep3) / 3) %>%
                     #drop raw info after spot checking averages
                     select(-contains("Rep"))
                    
#store inputs separately
inputs = percent_transcript %>%
         filter(Pool == "Input") %>%
         #drop Treatment column to avoid duplicates during merge
         select(-Pool) %>%
         rename("Avg_input_cpm" = Avg_cpm)

#bind inputs back to other pools and divide by inputs to get %
percent_total = percent_transcript %>%
                     #filter out inputs
                     filter(Pool != "Input") %>%
                     # bind inputs
                     merge(inputs, by = c("gene", "Treatment")) %>%
                     #calculate % of input 
                     # because we have normalized some ratios will be > 100%
                     mutate(percent_of_total = Avg_cpm/Avg_input_cpm * 100)

#format df for complex heatmap
df = percent_total %>%
     select(-contains("Avg")) %>%
     pivot_wider(names_from = c("Treatment", "Pool"),
                 values_from = "percent_of_total")

#prepare annotations
top_annot = data.frame(Name = colnames(df)[-1]) %>%
            separate(Name, into = c("Treatment", "Pool"), sep ="_")
rownames(top_annot) = colnames(df)[-1]

rwnmes = df$gene
H = df %>%
    select(-gene) %>%
    as.matrix()
rownames(H) = rwnmes
  
p<-Heatmap(H,
        column_title = "% of Total mRNA in Pool",
        name = "Avg_pool_cpm / Avg_input_cpm",
        show_row_names = F,
        show_column_names=F,
        #cluster_rows =T,
        cluster_columns = F,
        top_annotation = HeatmapAnnotation(df = top_annot,
                         col = list(Treatment = c(Control = "grey",
                                                   LSG2h = "#F89F7C",
                                                  LSG6h = "#F68064"),
                                   Pool = c("Pool1" = "#68C3A5", 
                                            "Pool2" ="#539C84",
                                            "Pool3" ="#3E7563")),
                          border = T,
                          show_legend = F,
                          annotation_name_gp = gpar(fontsize = 8)),
        column_split = top_annot$Treatment,
        column_gap = unit(2, "mm"),
        row_km = 20,
        row_gap = unit(0, "mm"),
        col = colorRamp2(c(0, 100, 200), c("white", "#8C9FCA", "darkblue"))
        )

#save plot
do_plot( "TE_analysis/Percent-mRNA-in-pool/FDR0.01/Pool-cpm_div_input-cpm.pdf", 8, 6, p)

#write csv
write.csv(as.matrix(H), path(output_dir, "TE_analysis/Percent-mRNA-in-pool/FDR0.01/Pool_cpm-div-Input_cpm.csv"))


#same plot but only 3,000 highly regulated transcripts

H_filt = H[rownames(DE_LFC_thresh),]
H_filt_scale = H_filt %>%
               t() %>%
               scale() %>%
               t()

p<-Heatmap(H_filt_scale,
        column_title = "% of Total mRNA in Pool",
        name = "Avg_pool_cpm / Avg_input_cpm",
        show_row_names = F,
        show_column_names=F,
        #cluster_rows =T,
        cluster_columns = F,
        top_annotation = HeatmapAnnotation(df = top_annot,
                         col = list(Treatment = c(Control = "grey",
                                                   LSG2h = "#F89F7C",
                                                  LSG6h = "#F68064"),
                                   Pool = c("Pool1" = "#68C3A5", 
                                            "Pool2" ="#539C84",
                                            "Pool3" ="#3E7563")),
                          border = T,
                          show_legend = F,
                          annotation_label = c("",""),
                          annotation_name_gp = gpar(fontsize = 8)),
        column_split = top_annot$Pool,
        column_gap = unit(2, "mm"),
        row_km = 30,
        row_gap = unit(0, "mm"),
        col = colorRamp2(c(min(H_filt_scale),-1, 0, max(H_filt_scale)), 
                         c("white", "white","#8C9FCA","darkblue"))
        )

#save plot
do_plot( "TE_analysis/Percent-mRNA-in-pool/FDR0.01/Pool-cpm_div_input-cpm_LFC_1-relative.pdf", 8, 6, p)

#write csv
write.csv(as.matrix(H_filt), path(output_dir, "TE_analysis/Percent-mRNA-in-pool/FDR0.01/Pool_cpm-div-Input_cpm_LFC_1.csv"))


####---- percent usage side by side with LFC
H2 = DE_LFC_thresh  
top_annot2 <- data.frame(Name = colnames(H2)) %>%
              separate(Name, into = c("Treatment", "Pool"), sep = "_")
rownames(top_annot2) = colnames(H2)


H2_scale = H2 %>%
           t() %>%
           scale() %>%
           t()

p2 <-Heatmap(H2_scale,
        column_title = "LFC",
        name = "Log2(Treated/Control)",
        show_row_names = F,
        show_column_names=F,
        #cluster_rows =T,
        cluster_columns = F,
        top_annotation = HeatmapAnnotation(df = top_annot2,
                         col = list(Treatment = c(Control = "grey",
                                                   LSG2h = "#F89F7C",
                                                  LSG6h = "#F68064"),
                                   Pool = c("Input" = "white",
                                            "Pool1" = "#68C3A5", 
                                            "Pool2" ="#539C84",
                                            "Pool3" ="#3E7563")),
                          border = T,
                          show_legend = T,
                          annotation_name_gp = gpar(fontsize = 8)),
        column_split = top_annot2$Treatment,
        column_gap = unit(2, "mm"),
        row_km = 30,
        row_gap = unit(0, "mm"),
        col = colorRamp2(c(-3,0,3), 
                         c("blue", "white","red"))
        )

p3 <- p+p2

#save plot for now (re-order clusters later)
do_plot( "TE_analysis/Percent-mRNA-in-pool/FDR0.01/LFC_1/PErcent-in-pool_PLUS_logfoldchange.pdf", 
         8, 6, p3)
```

#Re-design contrasts matrix
First approach: only perform comparisons in contrasts matrix
```{r}
##CONTRAST MATRIX----
# each contrast for DE will be one pool in treated - control (ie. LSG2h_input - Control_input)
# 1. get all treatments that arent control
# 2. make an equivalent list with the same pools in control
# 3. subtract 1 - 2
all_cond = levels(f)[!grepl("Control", (levels(f)))]
conts = gsub(".*_", "Control_", all_cond)
contrasts_list = str_c(all_cond, " - ", conts)

#DEFINE ADDT'L CONTRASTS FOR TE
# think about ways to streamline this
# set up df of contrasts to help with easy addition/subtraction
TE_contrasts = data.frame(contrasts = str_c("(", contrasts_list, ")")) %>%
               mutate(Treatment = gsub("\\(", "", gsub("_.*", "",contrasts)),
                      Pool = gsub(".*_", "", gsub(" - .*", "", contrasts))) %>%
               pivot_wider(names_from = "Treatment", values_from = "contrasts") %>%
               t() %>% #creates matrix
               data.frame() %>%
               #update naming for delta_Input column (change in mRNA = delta_mRNA)
               rename("Total" = X1,
                      "L" = X2,
                      "M" = X3,
                      "H" = X4,
                      "Polysome" = X5,
                      "Weighted.Polysome" = X6) %>%
               #hack for combining strings from different columns
               #create TE columns
               mutate(
                      Delta_Pool1 = str_c("(", 
                                 select(., L) %>% 
                                 reduce(paste0), 
                                 ") - (", 
                                 select(., Total) %>%
                                 reduce(paste0),
                                 ")"),
                      Delta_Pool2 = str_c("(", 
                                 select(., M) %>% 
                                 reduce(paste0), 
                                 ") - (", 
                                 select(., Total) %>%
                                 reduce(paste0),
                                 ")"),
                      Delta_Pool3 = str_c("(", 
                                 select(., H) %>% 
                                 reduce(paste0), 
                                 ") - (", 
                                 select(., Total) %>%
                                 reduce(paste0),
                                 ")"),
                      Polysomal_shift = str_c("(", 
                                 select(., M:H) %>% 
                                 reduce(str_c, sep=" + "), 
                                 ") - (", 
                                 select(., L) %>%
                                 reduce(paste0),
                                 ")"),
                      TE = str_c("(", 
                                 select(., Polysome) %>% 
                                 reduce(paste0), 
                                 ") - (", 
                                 select(., Total) %>%
                                 reduce(paste0),
                                 ")"),
                      Weighted_TE = str_c("(", 
                                 select(., Weighted.Polysome) %>% 
                                 reduce(paste0), 
                                 ") - (", 
                                 select(., Total) %>%
                                 reduce(paste0),
                                 ")")
                      )

#write csv of contrasts scheme for future reference
write.csv(as.matrix(TE_contrasts), path(output_dir, "TE_analysis/2024_01_04_TE_contrasts_matrix_updated.csv"))

#pivot contrasts table to get ready for named vector to feed into makeContrasts
TE_contrasts_pivot = TE_contrasts %>%
                     #drop un-needed contrasts
                     select(-c(Polysome, Weighted.Polysome)) %>% 
                     #drop descriptor row
                     filter(L != "Pool1") %>%
                     #add treatment names to prepare for pivot
                     mutate(Treatment = rownames(.), .before = 1) %>%
                     pivot_longer(-Treatment,
                                  names_to = "contrast_name", values_to = "contrast_value") %>%
                     #concatenate contrast_name and treatment
                     mutate(contrast_name = str_c(contrast_name, "_", Treatment))
                     

contrast.matrix <- makeContrasts(contrasts = TE_contrasts_pivot$contrast_value, 
                      levels = design)

#rename matrix according to naming scheme above
contrast.matrix = contrast.matrix %>%
                  as.data.frame() %>% #convert to df for now for manipulation 
                                      #(use as.data.frame to preserve names)
                  rename_all(~plyr::mapvalues(., 
                                              from = TE_contrasts_pivot$contrast_value,
                                              to = TE_contrasts_pivot$contrast_name)) %>%
                  as.matrix()

fit.cont <- contrasts.fit(fit, contrast.matrix)

e.fit <- eBayes(fit.cont)

#first bind together all LFC lists for all genes from ea. contrast
log2FC.all = as.data.frame(map_dfc(1:length(colnames(e.fit$contrasts)),
                             function(coef) topTable(e.fit, coef=coef, number=Inf, adjust = "BH",
                                                     sort.by='none')$logFC)) %>%
      data.frame()

adj_p = as.data.frame(map_dfc(1:length(colnames(e.fit$contrasts)),
                                    function(coef) topTable(e.fit, coef=coef, adjust = "BH",
                                                            number=Inf,
                                                            sort.by='none')$adj.P.Val))

rownames(log2FC.all) = rownames(adj_p) = make.unique(rownames(dge_norm_fltd), sep = ".")
colnames(log2FC.all) = colnames(adj_p) = colnames(e.fit$contrasts)

#turn log2FC.all.binary into matrix of -1,0,1
FDR_thresh = 0.1
log2FC.all.binary = adj_p %>%
              mutate_all(~ifelse(. < FDR_thresh, 1, 0))

#filter LFC matrix accordingly
log2FC.all.binary[(log2FC.all < 0) == T] = -1 * log2FC.all.binary[(log2FC.all < 0) == T]
names = rownames(log2FC.all.binary)
log2FC.all.binary = log2FC.all.binary %>%
                    data.frame()

#only use adj p vals from TE contrasts
DE_log2FC.all = log2FC.all[rowSums(log2FC.all.binary %>% select(contains("TE")) != 0) > 0,] %>%
                     data.frame()
rownames(DE_log2FC.all) = rownames(log2FC.all)[rowSums(log2FC.all.binary %>% 
                                                         select(contains("TE")) != 0) > 0]

#filter DE matrix based on LFC thresh
LFC_thresh = 0.5
DE_LFC_thresh = DE_log2FC.all %>%
                     filter(if_any(contains("TE"), ~ abs(.) > LFC_thresh))

#write csvs of DEGs and all log2FC
#write.csv(as.matrix(DE_LFC_thresh), path(output_dir, "TE_analysis/2024_01_TE/FDR0.01/LFC0.5/2024_01_04_translation_DEGs_fdr0.01_lfc0.5_lfc-matrix.csv"))

#save binary matrix
#write.csv(as.matrix(log2FC.all.binary), path(output_dir, "TE_analysis/2024_01_TE/FDR0.01/LFC0.5/2024_01_04_translation_DEGs_fdr0.01_lfc0.5_binary-sig-matrix.csv"))
```


Second Approach: follows more closely approach found here: https://github.com/barnalab/regeneration/blob/main/10302022code.R
- Sum relevent pools (Light + medium or Medium + heavy) in raw data
- Normalize sums (cpm)
- Then compute contrasts
```{r}
#First add LM, MH and sudo-free cols to raw data -- done in counts matrix above
```

Make pretty heatmaps!
```{r}
#set heatmap params----
#set seed for kmeans
set.seed(123)

#set fast clustering
ht_opt$fast_hclust = TRUE
ht_opt$message = FALSE

#prep data and make heatmaps----
cpm_all = cpm(dge_norm)
#write.csv(as.matrix(cpm), path(output_dir, "TE_analysis/2024_01_TE/fltd_cpm_matrix.csv"))

#start with percent of transcript heatmap (using sig TE genes)
  #bind rownames as its own column ('gene') to make sure gene names dont get lost during manipulation
percent_transcript = cbind(gene = rownames(DE_LFC_thresh), cpm_all[rownames(DE_LFC_thresh),]) %>%
                     #make df for easier manipulation
                     data.frame() %>%
                     #drop polysome/weighted polysome cols bc we dont care for now
                     select(-contains("Polysome")) %>%
                     #pivot longer so we can average over replicates
                     pivot_longer(cols = -gene, names_to ="Name", values_to = "cpm") %>%
                     #split "Name" column into relevant info
                     separate(Name, into = c("Treatment", "Rep", "Pool"), sep="_") %>%
                     #pivot wider to get reps in separate cols
                     pivot_wider(names_from = "Rep", values_from = "cpm") %>%
                     #make cpm numeric (preserving NA values)
                          #ifelse(!(is.na(.)), as.numeric(.), .)
                     mutate_at(.vars = vars(Rep1:Rep3), ~as.numeric(.)) %>%
                     #calculate average
                        #struggling to get rowwise operations working correctly
                        #so sticking to a more manual calc for now
                        #accounts for NA's
                     mutate(Avg_cpm = ifelse(
                                        !(is.na(Rep1)),
                                        (Rep1 + Rep2 + Rep3) / 3,
                                        (Rep2+Rep3)/2)
                                       ) %>%
                     #drop raw info after spot checking averages
                     select(-contains("Rep"))
                    
#store inputs separately
inputs = percent_transcript %>%
         filter(Pool == "Input") %>%
         #drop Treatment column to avoid duplicates during merge
         select(-Pool) %>%
         rename("Avg_input_cpm" = Avg_cpm)

#bind inputs back to other pools and divide by inputs to get %
percent_total = percent_transcript %>%
                     #filter out inputs
                     filter(Pool != "Input") %>%
                     # bind inputs
                     merge(inputs, by = c("gene", "Treatment")) %>%
                     #calculate % of input 
                     # because we have normalized some ratios will be > 100%
                     mutate(percent_of_total = Avg_cpm/Avg_input_cpm * 100)

#format df for complex heatmap
df = percent_total %>%
     select(-contains("Avg")) %>%
     pivot_wider(names_from = c("Treatment", "Pool"),
                 values_from = "percent_of_total")

#prepare annotations
top_annot = data.frame(Name = colnames(df)[-1]) %>%
            separate(Name, into = c("Treatment", "Pool"), sep ="_")
rownames(top_annot) = colnames(df)[-1]

rwnmes = df$gene
H = df %>%
    select(-gene) %>%
    as.matrix()
rownames(H) = rwnmes
  
p<-Heatmap(H,
        column_title = "% of Total mRNA in Pool; FDR < 0.1 | abs(LFC) > 0.5",
        name = "Avg_pool_cpm / Avg_input_cpm",
        show_row_names = F,
        show_column_names=F,
        cluster_rows =T,
        cluster_columns = F,
        top_annotation = HeatmapAnnotation(df = top_annot,
                         col = list(Treatment = c(Control = "grey",
                                                   LSG2h = "#F89F7C",
                                                  LSG6h = "#F68064"),
                                   Pool = c("Pool1" = "#68C3A5", 
                                            "Pool2" ="#539C84",
                                            "Pool3" ="#3E7563")),
                          border = T,
                          show_legend = F,
                          annotation_name_gp = gpar(fontsize = 8)),
        column_split = top_annot$Treatment,
        column_gap = unit(2, "mm"),
        #row_km = 20,
        row_gap = unit(0, "mm"),
        col = colorRamp2(c(0, 100, 200), c("white", "#8C9FCA", "darkblue"))
        )

#save plot
do_plot( "TE_analysis/2024_01_TE/FDR0.1/LFC0.5/complex_heatmap/percent_transcript_cpm_heatmap.pdf", 8, 6, p)

#write csv
write.csv(as.matrix(H), path(output_dir,
                             "TE_analysis/2024_01_TE/FDR0.1/LFC0.5/complex_heatmap/percent_transcript_cpm_heatmap-matrix.csv"))
```

#LFC + TE heatmaps
Start with LFC heatmap (2h & 6h together)
```{r}
H_LFC = DE_LFC_thresh %>%
        select(starts_with("Total"), starts_with("L"), starts_with("M"), starts_with("H")) %>%
        as.matrix()

#scale if desired
H_LFC_scale = H_LFC %>%
              t() %>%
              scale() %>%
              t()

topAnnot_LFC = data.frame(Name = colnames(H_LFC)) %>%
             separate(Name, into = c("Polysome Fraction", "Treatment"), sep = "_") %>%
             mutate(`Polysome Fraction` = gsub("L", "Light",
                                               gsub("M", "Medium", 
                                                    gsub("H", "Heavy", `Polysome Fraction`))),
                    `Polysome Fraction` = factor(`Polysome Fraction`, 
                                                 levels = c("Total", "Light", "Medium", "Heavy"))) %>%
             select(2,1) #reorder cols to match first heatmap
  
p<-Heatmap(H_LFC,
        column_title = "LFC",
        column_title_gp = gpar(fontsize=12),
        row_title_gp = gpar(fontsize=7),
        name = "log2(treated/control)",
        show_row_names = T,
        row_names_gp = gpar(fontsize = 2),
        show_column_names=F,
        #cluster_rows =T,
        cluster_columns = F,
        top_annotation = HeatmapAnnotation(df = topAnnot_LFC,
                         col = list(Treatment = c(Control = "grey",
                                                   LSG2h = "#F89F7C",
                                                  LSG6h = "#F68064"),
                                   `Polysome Fraction` = c("Total" = "white",
                                                          "Light" = "#68C3A5", 
                                                          "Medium" ="#539C84",
                                                          "Heavy" ="#3E7563")),
                          border = T,
                          show_legend = F,
                          annotation_label = c("",""),
                          annotation_name_gp = gpar(fontsize = 8)),
        column_split = topAnnot_LFC$Treatment,
        column_gap = unit(3, "mm"),
        row_km = 20,
        row_gap = unit(0, "mm"),
        border = T,
        #border_gp = gpar(col = "black", lwd = 2), 
        col = colorRamp2(c(-4,-0.1, 0, 0.1, 4), c("blue","white","white", "white", "red"))
        )

#save clusters, re-order
#get clusters----
p_drawn <- draw(p) #draw to lock in row clustering
p_drawn #run to show on screen and visually choose clusters

#use LFC to determine order instead of transcript distribution
rd <- row_order(p_drawn) #get row order & save
#reorder to make sure order is 1:20 so we dont have issues when assigning clusters
rd_ordered <- rd[order(as.numeric(names(rd)))] # make sure order is 1:20

#get cluster gene lists
cluster_list = list() #initialize empty list
for(i in 1:20){
  cluster_list[[i]] = data.frame(Cluster = i, 
                                 gene = c(rownames(H_LFC)[rd_ordered[[i]]]))
}
cluster_df = do.call(bind_rows, cluster_list)

#edit/condense clusters by eye
cluster_df_edit = cluster_df %>%
                  mutate(old_cluster = Cluster, 
                         Cluster = ifelse(old_cluster %in% c(19:20), 1,
                                        ifelse(old_cluster %in% c(15:18), 2,
                                               ifelse(old_cluster %in% c(13:14), 3,
                                                      ifelse(old_cluster %in% c(10:12), 4,
                                                             ifelse(old_cluster %in% c(7:9), 5,
                                                                    ifelse(old_cluster %in% c(4,6), 6, 
                                                                           ifelse(old_cluster %in% c(3,5), 7, 8))))))
                                          )) %>%
                  arrange(Cluster)

rownames(cluster_df_edit) = cluster_df_edit$gene

write.csv(as.matrix(cluster_df_edit), 
          path(output_dir,
                 "TE_analysis/2024_01_TE/FDR0.1/LFC0.5/20240108_2h6h_compiled_lfc_heatmap_fdr0.1_lfc0.5_8-clusters.csv"))

#re-order H_LFC and re-draw heatmap (please make a function for this soon kate!!!!)----
H_LFC_reorder = H_LFC[cluster_df_edit$gene,]

topAnnot_LFC = data.frame(Name = colnames(H_LFC_reorder)) %>%
               separate(Name, into = c("Polysome Fraction", "Treatment"), sep = "_") %>%
               mutate(`Polysome Fraction` = gsub("L", "Light",
                                               gsub("M", "Medium", 
                                                    gsub("H", "Heavy", `Polysome Fraction`))),
                    `Polysome Fraction` = factor(`Polysome Fraction`, 
                                                 levels = c("Total", "Light", "Medium", "Heavy"))) %>%
               select(2,1) #reorder cols to match first heatmap


left_annot = cluster_df_edit %>% select(Cluster)
  
p<-Heatmap(H_LFC_reorder,
        column_title = "LFC",
        column_title_gp = gpar(fontsize=12),
        row_title_gp = gpar(fontsize=7),
        cluster_row_slices = T,
        name = "log2(treated/control)",
        show_row_names = F,
        show_column_names=F,
        cluster_rows = F,
        cluster_columns = F,
        top_annotation = HeatmapAnnotation(df = topAnnot_LFC,
                         col = list(Treatment = c(Control = "grey",
                                                   LSG2h = "#F89F7C",
                                                  LSG6h = "#F68064"),
                                   `Polysome Fraction` = c("Total" = "white",
                                                          "Light" = "#68C3A5", 
                                                          "Medium" ="#539C84",
                                                          "Heavy" ="#3E7563")),
                          border = T,
                          show_legend = F,
                          annotation_label = c("",""),
                          annotation_name_gp = gpar(fontsize = 8)),
        left_annotation = rowAnnotation(Cluster = left_annot$Cluster,
                                            col = list(Cluster = 
                                                         c(`1` = "#ED6868",
                                                           `2` = "#F4908E",
                                                           `3` = "#EED290",
                                                           `4` = "#5BABA4",
                                                           `5` = "#A6DFF7",
                                                           `6` = "#A5C7DE",
                                                           `7` = "#C0ACD0",
                                                           `8` = "#9E7FB8"))
                                       ),
        column_split = topAnnot_LFC$Treatment,
        column_gap = unit(3, "mm"),
        #row_km = 20,
        row_split = left_annot$Cluster,
        row_gap = unit(0, "mm"),
        border = T,
        #border_gp = gpar(col = "black", lwd = 2), 
        col = colorRamp2(c(-4,-0.1, 0, 0.1, 4), c("blue","white","white", "white", "red"))
        )

#save intermediate heatmap
do_plot("TE_analysis/2024_01_TE/FDR0.1/LFC0.5/complex_heatmap/LFC_2h-6h_fdr0.1_lfc0.5_8-clusters.pdf",
        8,6,p2)
```

Now make TE heatmap
```{r}
#make TE heatmap
H_TE = DE_LFC_thresh %>%
        select(starts_with("TE")) %>%
        as.matrix()

#reorder data to match
H_TE = H_TE[rownames(H_LFC_reorder), ]

topAnnot_TE = data.frame(Name = colnames(H_TE)) %>%
              separate(Name, into = c("Metric", "Treatment"), sep = "_") %>%
              #select(-Metric)
              mutate(Metric = gsub("delta.mRNA", "\U0394mRNA",
                                  gsub("TE", "\U0394TE",
                                        Metric)),
                     Metric = factor(Metric, levels = c("\U0394mRNA", "\U0394TE"))
                     ) %>%
              select(2,1) # reoder so color blocks appear correctly

pTE2<-Heatmap(H_TE,
        column_title = "TE",
        column_title_gp = gpar(fontsize=12),
        row_title_gp = gpar(fontsize=7),
        name = "log2(polysome/total)",
        show_row_names = F,
        show_column_names=F,
        cluster_rows =T,
        cluster_columns = F,
        top_annotation = HeatmapAnnotation(df = topAnnot_TE,
                         col = list(Treatment = c(Control = "grey",
                                                   LSG2h = "#F89F7C",
                                                  LSG6h = "#F68064"),
                                    Metric = c("\U0394TE" = "#AED29E")),
                          border = T,
                          show_legend = F,
                          annotation_label = c("",""),
                          annotation_name_gp = gpar(fontsize = 8)),
        column_split = topAnnot_TE$Treatment,
        column_gap = unit(1.5, "mm"),
        row_km = 30,
        row_gap = unit(0, "mm"),
        border = T,
        col = colorRamp2(c(-1.5,-1,0,1,1.5), c("darkblue","#8C9FCA","white", "orangered","firebrick")))

#put LFC + TE together
pCombn<-p2 +pTE
pCombn<-draw(pCombn)
rd2 <- row_order(pCombn) #get row order for ordering csv files

#first iteration plot save
do_plot("TE_analysis/2024_01_TE/FDR0.1/LFC0.5/complex_heatmap/lfc_te_2h6h_fdr0.1_lfc0.5_arrangedByLFC.pdf", 8,6, pCombn)

#try ordering by TE instead of LFC
pTE+p2

#check that both heatmaps are ordered the same before binding 
#sum(rownames(H_LFC_reorder) != rownames(H_TE)) > 0

morpheus_heatmap = cbind(H_LFC_reorder, H_TE, Cluster = cluster_df_edit$Cluster) %>%
                   data.frame() %>%
                   select(Cluster, ends_with("2h"), ends_with("6h"))


write.csv(as.matrix(morpheus_heatmap), 
          path(output_dir, "TE_analysis/2024_01_TE/FDR0.1/LFC0.5/morpheus_heatmaps/20240112_fdr0.1_lfc0.5_clusterorder_undedited.csv"))


#visualize in morpheus and re-assign genes visually to fit aesthetically appropriate clusters
```

Remake LFC + TE heatmaps based on manually edited/re-assigned clusters (pulling out groups of genes where LFC and TE are in the opposite direction to be in their own clusters to make things easier to see visually)
```{r}
#import manually assigned cluster info
manual_assnmt = read_csv(path(output_dir,
                              "TE_analysis/2024_01_TE/FDR0.1/LFC0.5/morpheus_heatmaps/20240112_manually_reassigned_clusters.csv"))

cluster_df_manual = cluster_df_edit %>%
                    rename(Original= old_cluster,
                           Intermediate = Cluster) %>%
                    mutate(Cluster = ifelse(gene %in% manual_assnmt$Gene[manual_assnmt$Categorization == "neg"], 9,
                                          ifelse(gene %in% manual_assnmt$Gene[manual_assnmt$Categorization == "pos"], 10, 
                                                 Intermediate))) %>%
                    arrange(Cluster)

cluster_df_manual2 =  cluster_df_manual %>%
                      rename(Manual1 = Cluster) %>%
                      mutate(Cluster = ifelse(Manual1 %in% c(1,2), 1,
                                          ifelse(Manual1 %in% c(3:5), Manual1-2,
                                              ifelse(Manual1 == 6, 6,
                                                  ifelse(Manual1 %in% c(7,8), 7, 
                                                      ifelse(Manual1 == 9, 5,
                                                          ifelse(Manual1 == 10, 4,
                                                                 Manual1))))))) %>%
                      arrange(Cluster)

#re-save clusters!!!
write.csv(as.matrix(cluster_df_manual2),
          path(output_dir,
               "TE_analysis/2024_01_TE/FDR0.1/LFC0.5/complex_heatmap/cluster_lists/20240115_final_7_clusters.csv"))

H_LFC_reorder = H_LFC[cluster_df_manual2$gene,]

topAnnot_LFC = data.frame(Name = colnames(H_LFC_reorder)) %>%
               separate(Name, into = c("Polysome Fraction", "Treatment"), sep = "_") %>%
               mutate(`Polysome Fraction` = gsub("L", "Light",
                                               gsub("M", "Medium", 
                                                    gsub("H", "Heavy", `Polysome Fraction`))),
                    `Polysome Fraction` = factor(`Polysome Fraction`, 
                                                 levels = c("Total", "Light", "Medium", "Heavy"))) %>%
               select(2,1) #reorder cols to match first heatmap


left_annot = cluster_df_manual2 %>% 
             select(Cluster) %>%
             mutate(split = ifelse(Cluster %in% c(1:5), "TE_up", "TE_down"),
                    split = factor(split, levels = c("TE_up", "TE_down")))
  
p<-Heatmap(H_LFC_reorder,
        column_title = "LFC",
        column_title_gp = gpar(fontsize=12),
        row_title_gp = gpar(fontsize=7),
        cluster_row_slices = T,
        name = "log2(treated/control)",
        show_row_names = F,
        show_column_names=F,
        cluster_rows = F,
        cluster_columns = F,
        top_annotation = HeatmapAnnotation(df = topAnnot_LFC,
                         col = list(Treatment = c(Control = "grey",
                                                   LSG2h = "#F89F7C",
                                                  LSG6h = "#F68064"),
                                   `Polysome Fraction` = c("Total" = "white",
                                                          "Light" = "#68C3A5", 
                                                          "Medium" ="#539C84",
                                                          "Heavy" ="#3E7563")),
                          border = T,
                          show_legend = F,
                          annotation_label = c("",""),
                          annotation_name_gp = gpar(fontsize = 8)),
        left_annotation = rowAnnotation(Cluster = left_annot$Cluster,
                                            col = list(Cluster = 
                                                         c(`1` = "#ED6868",
                                                           `2` = "#F4908E",
                                                           `3` = "#EED290",
                                                           `4` = "#AED29E",
                                                           `5` = "#5BABA4",
                                                           `6` = "#A6DFF7",
                                                           `7` = "#A5C7DE",
                                                           `8` = "#C0ACD0",
                                                           `9` = "#9E7FB8",
                                                           `10` = "#AE9492"
                                                           ),
                                        annotation_label = "")
                                       ),
        column_split = topAnnot_LFC$Treatment,
        column_gap = unit(3, "mm"),
        #row_km = 20,
        row_split = left_annot$Cluster,
        row_gap = unit(c(rep(0,3),3,rep(0,2)), "mm"),
        border = T,
        #border_gp = gpar(col = "black", lwd = 2), 
        col = colorRamp2(c(-4,-0.1, 0, 0.1, 4), c("blue","white","white", "white", "red"))
        )

#TE heatmap
H_TE =  DE_LFC_thresh %>%
        select(starts_with("TE")) %>%
        as.matrix()

#reorder data to match
H_TE = H_TE[rownames(H_LFC_reorder), ]

topAnnot_TE = data.frame(Name = colnames(H_TE)) %>%
              separate(Name, into = c("Metric", "Treatment"), sep = "_") %>%
              #select(-Metric)
              mutate(Metric = gsub("delta.mRNA", "\U0394mRNA",
                                  gsub("TE", "\U0394TE",
                                        Metric)),
                     Metric = factor(Metric, levels = c("\U0394mRNA", "\U0394TE"))
                     ) %>%
              select(2,1) # reoder so color blocks appear correctly

pT <-Heatmap(H_TE,
        column_title = "TE",
        column_title_gp = gpar(fontsize=12),
        row_title_gp = gpar(fontsize=7),
        name = "log2(polysome/total)",
        show_row_names = F,
        show_column_names=F,
        cluster_row_slices = T,
        cluster_rows =F,
        cluster_columns = F,
        top_annotation = HeatmapAnnotation(df = topAnnot_TE,
                         col = list(Treatment = c(Control = "grey",
                                                   LSG2h = "#F89F7C",
                                                  LSG6h = "#F68064"),
                                    Metric = c("\U0394TE" = "#AED29E")),
                          border = T,
                          show_legend = F,
                          annotation_label = c("",""),
                          annotation_name_gp = gpar(fontsize = 8)),
        column_split = topAnnot_TE$Treatment,
        column_gap = unit(1.5, "mm"),
        row_split = left_annot,
        #row_km = 30,
        row_gap = unit(0, "mm"),
        border = T,
        col = colorRamp2(c(-1.5,-1,0,1,1.5), c("darkblue","#8C9FCA","white", "orangered","firebrick")))

final <- p+pT
do_plot("TE_analysis/2024_01_TE/FDR0.1/LFC0.5/complex_heatmap/20240112_lfc_te_2h6h_fdr0.1_lfc0.5_arrangedByLFC_manual-edit3-7clusters.pdf", 8,6, final)
```



#mRNA v TE correlation plot
```{r}

mini_binary <- cbind(gene = rownames(log2FC.all.binary), 
                       log2FC.all.binary %>% 
                             select(contains("TE"), 
                             contains("mRNA"))) %>%
                rename_at(-1,~str_c(., "_sig"))

#consider adding additional columns for different FDRs
comparison_df = log2FC.all %>%
                select(contains("mRNA"), contains("TE")) %>%
                rownames_to_column("gene") %>%
                merge(mini_binary, by = "gene") %>%
                pivot_longer(-c(gene, contains("sig")), names_to = "metric", values_to = "LFC") %>%
                separate(metric, into = c("metric", "Treatment"), sep = "_") %>%
                mutate(metric = gsub("delta.mRNA", "LFC mRNA",
                                     gsub("TE", "LFC TE", metric))) %>%
                pivot_longer(contains("_sig"), names_to = "metric2", values_to = "sig") %>%
                separate(metric2, into= c("metric2", "Treatment2", "junk"), sep = "_") %>%
                filter(Treatment == Treatment2 & grepl("TE", metric) == grepl("TE", metric2)) %>%
                select(-c(Treatment2, metric2, junk)) %>%
                mutate(metric = gsub("LFC ", "", metric)) %>%
                pivot_wider(names_from = "metric", values_from = c("LFC", "sig")) %>%
                #categorize according to zhulyn et al definitions
                mutate(category = ifelse(LFC_TE > 1 & LFC_mRNA < 1 & LFC_mRNA > -1,
                                         "TE UP (no \U0394 mRNA)",
                                         ifelse(LFC_TE < -1 & LFC_mRNA > -1,
                                         "TE DOWN (no \U0394 mRNA)",
                                         ifelse(LFC_TE > 1 & LFC_mRNA > 1,
                                         "mRNA UP and TE UP",
                                         ifelse(LFC_TE < -1 & LFC_mRNA < -1,
                                         "mRNA DOWN and TE DOWN",
                                         ifelse(LFC_TE < -1  & LFC_mRNA > 1,
                                         "mRNA UP and TE DOWN",
                                         ifelse(LFC_TE > 1  & LFC_mRNA < -1,
                                         "mRNA DOWN and TE UP",
                                         ifelse(LFC_TE < 1 & LFC_mRNA > 1,
                                         "mRNA UP (no \U0394 TE)",
                                         ifelse(LFC_TE > -1 & LFC_mRNA < -1,
                                         "mRNA DOWN (no \U0394 TE)", "no change")))))))),
                       category = factor(category, levels = c("TE UP (no \U0394 mRNA)", "TE DOWN (no \U0394 mRNA)",
                                                              "mRNA UP and TE UP", "mRNA DOWN and TE DOWN",
                                                              "mRNA UP (no \U0394 TE)", "mRNA DOWN (no \U0394 TE)",
                                                              "mRNA UP and TE DOWN", "mRNA DOWN and TE UP",
                                                              "no change")))


MT_colors = c("#9E7FB8","#C0ACD0", "#ED6868", "#DA9B90","#F4908E", "#AE9492","#AED29E", "#5BABA4",
              "#D278AE", "#A6DFF7", "#A5C7DE","#F29D65", "#EED290")
zhulyn_colors = c("#6FBE44","#176533", "#C277B1", "#FAA41A", "#6D91CB", "#BFBEBE")
   
    #"#F6E4EE"

mRNA_TE_plot <- ggplot(comparison_df, aes(x = `LFC_mRNA`, y = `LFC_TE`, color = category)) +
  geom_point(data = subset(comparison_df, category == "no change"), size =0.75) +
  geom_point(data = subset(comparison_df, category != "no change" & !(sig_mRNA != 0 | sig_TE != 0)),
             size =0.75, color = "black") +
  geom_point(data = subset(comparison_df, category != "no change" & (sig_mRNA != 0 | sig_TE != 0)), 
             size =0.75)  +
  scale_color_manual(values = c("#AED29E","#176533", "#D278AE","#EDC9DE", 
                                "#FAA41A","#A6DFF7","#C0ACD0", "#9E7FB8","#BFBEBE"), drop = F) +
  #add dashed lines for cut-offs
  geom_hline(yintercept = 1, color = "grey", linetype =2) +
  geom_hline(yintercept = -1, color = "grey", linetype =2) +
  geom_vline(xintercept = 1, color = "grey", linetype =2) +
  geom_vline(xintercept = -1, color = "grey", linetype =2) +
  geom_smooth(method = 'lm',formula= y~x, se=F, col='black', size =0) +
  stat_cor(aes(label = ..rr.label..),
           label.y = 7, 
           size=4, color = 'black') +
  facet_wrap(~Treatment, scales = "fixed") +
  xlim(-7.5,7.5) +
  labs(y = expression("log"["2"] ~ "FC  TE"),
       x = expression("log"["2"] ~ "FC  mRNA")) +
  theme_classic() +
  theme(strip.background = element_rect(color = "white"),
        strip.text = element_text(face = "bold", size = 14),
        legend.position = "bottom",
        legend.text = element_text(size = 5),
        legend.title = element_text(size=8),
        legend.key.size = unit(0.1,'inches'),
        panel.background = element_rect(color = "black"))


save_plot(path(output_dir, 
               "TE_analysis/FDR0.01/FDR0.01_LFC1/20231115_mRNA-v-TE-correlation_zhulyn_all_genes.pdf"), 
          mRNA_TE_plot)



LSG2h <- comparison_df %>% 
         filter(category == "TE UP (no \U0394 mRNA)" & sig_TE==1 & Treatment == "LSG2h")

LSG6h <- comparison_df %>% 
         filter(category == "TE UP (no \U0394 mRNA)" & sig_TE==1 & Treatment == "LSG6h")

overlap<-LSG2h %>%
         filter(gene %in% LSG6h$gene)

LSG6h_only<-LSG6h %>%
            filter(!(gene %in% LSG2h$gene))

write.csv(as.matrix(LSG6h_only),
          path(output_dir,
               "TE_analysis/FDR0.01/FDR0.01_LFC1/TE_up_mRNA_noChange_genes_LFC1_sigFDR0.01_LSG6h_UNIQUE.csv"))
write.csv(as.matrix(LSG6h),
          path(output_dir, 
               "TE_analysis/FDR0.01/FDR0.01_LFC1/TE_up_mRNA_noChange_genes_LFC1_sigFDR0.01_LSG6h.csv"))
write.csv(as.matrix(overlap),
          path(output_dir, 
               "TE_analysis/FDR0.01/FDR0.01_LFC1/TE_up_mRNA_noChange_genes_LFC1_sigFDR0.01_overlap.csv"))

#get group of genes that are interesting for follow-up
int_genes <- subset(comparison_df, abs(`LFC mRNA`) < 1 & abs(`LFC TE`) > 1)
int_genes_up <- subset(comparison_df, abs(`LFC mRNA`) < 1 & `LFC TE` > 1)
int_genes_sig <- int_genes_up %>%
                 left_join(mini_binary, by = "gene") %>%
                 filter(!(TE_LSG2h == 0 & TE_LSG6h == 0)) %>%
                 rename_at(c(5:6), ~str_c(., "_sig")) %>%
                 mutate_at(c(5:6), ~as.logical(.)) %>%
                 arrange(gene)

write.csv(as.matrix(int_genes_sig), path(output_dir, "TE_analysis/FDR0.01/FDR0.01_LFC1/TE_up_mRNA_noChange_genes_LFC1_sigFDR0.01.csv"))
```

#single gene cpm plots
```{r}
int_genes <- list(h2 = c("Bcl2l1", "Ccl5", "Eif1", "Eif3e", "Eif3f", "H2.M3",
                      "H2.Q7", "Jun", "Polr2g", "Rack1", "S100a4", "Saa3"),
                  h6 = c("Cd47", "Cdkn1a","Eef1g","Eif1a","Irak2", "Irf9", "Nfat5",
                      "Notch2", "Polr1c", "Runx3", "Traf6"),
                  shared = c("Btf3","Eef1a1", "Eef2", "Fau", "Gdf15", "Serpinb6b", "Traf5"))

cluster_genes <- list(cluster1 = c( "Rsad2", "Il6", 
                                   "Ifnb1",  "Isg15"),
                      cluster2 = c( "Rpl11", "Rpl27", "Gdf15","Rack1"),
                      cluster3 = c( "Jun","Kras", "Marco", "Psmb7"),
                      cluster4 = c("Gstp1",  "Ndufs7", "Acadm", "Aldh3b1"),
                      cluster5 = c("Runx1", "Tgfbr1", "Btk",
                                   "Eif4ebp2"),
                      cluster6 = c("Cebpa", "Myc", "Foxo3", "Il6ra"))

cluster_genes2 <- list(cluster1 = c("Oas1a", "Rsad2", "Nlrp3", "Cd86",
                                   "Irf7", "Cxcl10", "Il6", "Ifna2",
                                   "Ifnb1", "Ifit2", "Ifit3", "Isg15",
                                   "Tlr2"),
                      cluster2 = c("Rps15", "Rpl11", "Rpl27", "Gdf15",
                                   "Eef2", "Eif3e", "Rack1"),
                      cluster3 = c("Bcl2l1", "Zeb1", "Notch2", "Jun",
                                   "Kras", "Irak2", "Clec2d", "Marco",
                                   "Traf3", "Traf6", "Tap2", "Irf8",
                                   "Ccr7", "Psmb7", "Stat1", "Stat3",
                                   "Cnot4", "Ubr4"),
                      cluster4 = c("Gstp1", "Timm22", "Ndufs7",
                                   "Nudt2", "Acadm", "Aldh3b1",
                                   "Me2"),
                      cluster5 = c("Mrpl12", "Slc25a30", "Pus1",
                                   "Runx1", "Tgfbr1", "Btk", "Irak4",
                                   "Eif4ebp2"),
                      cluster6 = c("Cebpa", "Myc", "Foxo3"))

#prep cpm data for plotting
cpm_df_cluster = cpm_all %>%
              data.frame() %>%
              rownames_to_column(var = "gene") %>%
              filter(gene %in% (cluster_genes %>% unlist())) %>%
              #select(c("gene", contains("Pool"))) %>%
              pivot_longer(cols = -gene, 
                           names_to = "Treatment_Rep_Pool",
                           values_to = "cpm") %>%
              separate(Treatment_Rep_Pool, 
                       into = c("Treatment", "Rep", "Pool"), 
                       sep = "_") %>%
              pivot_wider(names_from = "Rep", values_from = "cpm") %>%
              #calculate average and se
              mutate(Pool = ifelse(Pool == "Input", 0, as.numeric(gsub("Pool", "", Pool))),
                     Avg_cpm = (Rep1 + Rep2 + Rep3)/3,
                     se = sqrt(((Rep1-Avg_cpm)^2 + (Rep2-Avg_cpm)^2 +
                                  (Rep3-Avg_cpm)^2)/3)/sqrt(3))
#plot
for(i in 1:6){
  p<-ggplot(cpm_df_cluster %>% filter(gene %in% cluster_genes[[i]]),
       aes(x = Pool, y = Avg_cpm, color = Treatment)) +
       geom_line(size=1) +
       geom_point() +
       geom_errorbar(aes(ymin=Avg_cpm - se, ymax= Avg_cpm + se),
                     width=0.25, size=1) +
       scale_color_manual(values = c(Control = "grey",
                                     LSG2h = "#FAC5B0",
                                     LSG6h = "#F68064")) +
       facet_wrap(~gene, scales="free_y", nrow=1) +
       labs(x = "Polysome Pool", title = str_c("Cluster",
                                               as.character(i))) +
       theme(legend.position = "bottom")

save_plot(path(output_dir,
               str_c("TE_analysis/FDR0.01/FDR0.01_LFC1/mRNA_TE_correlation/TE_up_gene-lists/single_gene_plots/Clusters/Mini_clusters/LSG2h_heatmap_Cluster_",
                     as.character(i), ".pdf")),
          p)

}

#save df
write.csv(as.matrix(cpm_df_int_test), path(output_dir,
               "TE_analysis/FDR0.01/FDR0.01_LFC1/mRNA_TE_correlation/TE_up_gene-lists/single_gene_plots/cpm_df_int_genes.csv"))
```


#TE v protein correlation
```{r}
#read in protein data
lfc_table_all = read.csv(fs::path(prot_input_dir, "Compiled_lfcTable_AllDatasets_092222.csv")) %>%
            data.frame() %>%
            mutate(X = NULL) 

#filter to grab only protein data
prot_lfc = lfc_table_all %>% 
           filter(dataset == "Protein") %>%
           #only care about triplet data for now
           filter(combo == "LSG") %>%
           filter(treatment == "LFC_tr") %>%
           #trim unnecessary columns
           select(-c(run, triplet, dataset, dose, treatment, 
                     stdev_names, stdev, SE, meanSE, combo)) %>%
           #rename LFC column in prep for binding with TE data
           rename("Protein_LFC" = value,
                  "Protein_time" = time,
                  "Protein_category" = category)

mRNA_LFC = lfc_table_all %>% 
           filter(run == "Adil_Exp1") %>%
           #only care about triplet data for now
           filter(combo == "LSG") %>%
           filter(treatment == "LFC_tr") %>%
           #trim unnecessary columns
           select(-c(run, triplet, dataset, dose, treatment, 
                     stdev_names, stdev, SE, meanSE, combo)) %>%
           #rename LFC column in prep for binding with TE data
           rename("mRNA_LFC" = value,
                  "mRNA_time" = time,
                  "mRNA_category" = category,
                  "mRNA_category2" = category_2)

#use mRNA_TE comparison_df data for merge
#merge with TE data
prot_TE_mRNA_merge = prot_lfc %>%
                inner_join(mRNA_LFC,by = "gene") %>%
                inner_join(comparison_df %>% 
                          select(-contains("mRNA")) %>%
                          rename("TE_category" = category,
                                 "TE_time" = Treatment,
                                 "TE_LFC" = LFC_TE), by = "gene") %>%
                mutate(TE_time = str_c("TE_", gsub("LSG", "" ,gsub("h", "", TE_time)), "h"),
                       Protein_time = str_c("Protein_", Protein_time, "h"),
                       mRNA_time = str_c("mRNA_", mRNA_time, "h"),
                       TE_category = factor(TE_category, levels= c("TE UP (no \U0394 mRNA)", "TE DOWN (no \U0394 mRNA)",
                                                              "mRNA UP and TE UP", "mRNA DOWN and TE DOWN",
                                                              "mRNA UP (no \U0394 TE)", "mRNA DOWN (no \U0394 TE)",
                                                              "mRNA UP and TE DOWN", "mRNA DOWN and TE UP",
                                                              "no change")),
                       Protein_category = factor(Protein_category, 
                                                 levels = c("antagonism.sig", "antagonism", "additive",
                                                                        "synergy","synergy.sig")),
                       category_2 = gsub(".*roughly.", "", gsub('same', "no change", category_2)),
                       category_2 = factor(category_2, 
                                           levels = c("antagonism", "additive", "no change", "synergy"))) %>%
                       rename("Interaction Category" = category_2)

 
#figureout all timewise comparisons
p<-ggplot(prot_TE_merge, aes(x = Protein_LFC, y = TE_LFC, color = TE_category))+
  geom_point(alpha = 0.6, size = 0.2) +
  geom_point(data = subset(prot_TE_merge, 
                           TE_category == "TE UP (no \U0394 mRNA)" | TE_category == "TE DOWN (no \U0394 mRNA)"),
             alpha = 0.6, size = 0.2) +
  geom_point(data = subset(prot_TE_merge, 
                           TE_category == "mRNA UP (no \U0394 TE)" | TE_category == "mRNA DOWN (no \U0394 TE)"),
             alpha = 0.6, size = 0.2) +
  #geom_smooth(method = 'lm', se=F,  color= "black",
    #          formula = y~x,size =0.25,
    #          linetype=1) +
  facet_grid(TE_time~Protein_time) +
  scale_color_manual(values = c("#AED29E","#176533", "#D278AE","#EDC9DE", 
                                "#FAA41A","#A6DFF7","#C0ACD0", "#9E7FB8","#BFBEBE")) +
  #geom_text_repel(data = subset(prot_TE_merge, gene == "Cxcl10"),aes(label = gene)) +
  stat_cor(aes(label = ..rr.label..),label.x=-8, size=2, show.legend=F) +
  labs(x = "Protein (LFC)", y = "TE (LFC)") +
  theme(#strip.text = element_text(size = rel(0.5)), 
        strip.text.x = element_text(margin = margin(0.05,0.05,0.05,0.05, "cm"), face = "bold"),
        strip.text.y = element_text(margin = margin(0.05,0.05,0.05,0.05, "cm"), face = "bold"),
        strip.background = element_rect(size=0.35, color="black"),
        text = element_text(size=rel(4)),
        legend.position = "none")

p2<-ggplot(prot_TE_merge, aes(x = Protein_LFC, y = TE_LFC, color = `Interaction Category`)) +
  geom_point(alpha = 0.6, size = 0.2) +
  geom_point(data = subset(prot_TE_merge, 
                           `Interaction Category` == "additive"),
             alpha = 0.6, size = 0.2) +
  geom_point(data = subset(prot_TE_merge, 
                           `Interaction Category` == "antagonism" | `Interaction Category` == "synergy"),
             alpha = 0.6, size = 0.2) +
  #geom_smooth(method = 'lm', se=F,  color= "black",
    #          formula = y~x,size =0.25,
    #          linetype=1) +
  facet_grid(TE_time~Protein_time) +
  scale_color_manual(values = c(antagonism ="blue", additive = "grey30", "no change" = "grey86", synergy ="red")) +
  geom_text_repel(data = subset(prot_TE_merge, (`Interaction Category` != "no change" & Protein_time != "Protein_4h" ) |
                                  ((`Interaction Category` == "antagonism" | `Interaction Category` == "synergy" ) &
                                     Protein_time == "Protein_4h" & abs(Protein_LFC) > 1)),
                  aes(label = gene),
                  size = 1,
                  max.overlaps = 10,
                  min.segment.length = 4,
                  force_pull=5,
                  box.padding=0,
                  segment.size=0.2,
                  nudge_x = 0.25,
                  nudge_y = 0.25,
                  seed=123) +
  stat_cor(aes(label = ..rr.label..),label.x=-8, size=2, show.legend=F) +
  labs(x = "Protein (LFC)", y = "TE (LFC)") +
  theme(#strip.text = element_text(size = rel(0.5)), 
        strip.text.x = element_text(margin = margin(0.05,0.05,0.05,0.05, "cm"), face = "bold"),
        strip.text.y = element_text(margin = margin(0.05,0.05,0.05,0.05, "cm"), face = "bold"),
        strip.background = element_rect(size=0.35, color="black"),
        text = element_text(size=rel(4)),
        legend.position = "none",
        legend.background = element_rect(color = "white"))

#now look at overlap with non-additive proteins and TE UP/DOWN genes
filt_df = prot_TE_merge %>% filter(TE_category == "TE UP (no \U0394 mRNA)" | TE_category == "TE DOWN (no \U0394 mRNA)")
filt_df2 = prot_TE_merge %>% filter(TE_category == "mRNA UP and TE UP")

p4<-ggplot(filt_df2, aes(x = Protein_LFC, y = TE_LFC, color = `Interaction Category`)) +
  #geom_point(data = prot_TE_merge, alpha = 0.6, size = 0.2, color = "grey85") +
  geom_point(data = filt_df2, alpha = 0.6, size = 0.2, aes(color = TE_category)) +
  geom_point(data = subset(filt_df2, 
                           `Interaction Category` == "additive"),
             alpha = 0.6, size = 0.2) +
  geom_point(data = subset(filt_df2, 
                           `Interaction Category` == "antagonism" | `Interaction Category` == "synergy"),
             alpha = 1, size = 0.3) +
 # geom_smooth(method = 'lm', se=F,  color= "#D278AE",
    #          formula = y~x,size =0.25,
    #          linetype=1) +
  facet_grid(TE_time~Protein_time) +
  scale_color_manual(values = c(antagonism ="blue", additive = "grey30", 
                                "no change" = "grey86", synergy ="red",
                                "TE UP (no \U0394 mRNA)" = "#AED29E",
                                "TE DOWN (no \U0394 mRNA)" = "#176533",
                                "mRNA UP and TE UP" = "#D278AE")) +
  geom_text_repel(data = subset(filt_df2, (`Interaction Category` != "no change")),
                  aes(label = gene),
                  size = 1.3,
                  max.overlaps = 30,
                  min.segment.length = 4,
                  force_pull=5,
                  box.padding=0,
                  segment.size=0.2,
                  nudge_x = 0.25,
                  nudge_y = 0.25,
                  seed=123) +
  stat_cor(aes(label = ..rr.label..),label.x=-4, size=2.5, color = "#D278AE", show.legend=F) +
  labs(x = "Protein (LFC)", y = "TE (LFC)") +
  theme(#strip.text = element_text(size = rel(0.5)), 
        strip.text.x = element_text(margin = margin(0.05,0.05,0.05,0.05, "cm"), face = "bold"),
        strip.text.y = element_text(margin = margin(0.05,0.05,0.05,0.05, "cm"), face = "bold"),
        strip.background = element_rect(size=0.35, color="black"),
        text = element_text(size=rel(4)),
        legend.position = "none",
        legend.background = element_rect(color = "white"))


#save plot
save_plot(path(output_dir,
               "TE_analysis/FDR0.01/FDR0.01_LFC1/Protein_TE_correlation/Protein_v_TE_overlapping-genes-bulk_TEup_mRNAup-only.pdf"),
          p4, dpi=90)
#repeat with mRNA correlation of triplet vs protein

#and mRNA vs TE using adil's data

#start with matrix of all possible time-wise comparisons
```

